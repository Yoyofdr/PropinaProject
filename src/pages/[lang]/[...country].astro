---
export async function getStaticPaths() {
  const modules = import.meta.glob('../../../content/*/*.json');
  const paths = [];
  for (const path in modules) {
    const match = path.match(/content\/([^/]+)\/([^/]+)\.json$/);
    if (match) {
      const lang = match[1];
      const mod = await modules[path]();
      const slug = mod.default?.slug || mod.slug;
      if (slug) {
        paths.push({ params: { lang, country: slug } });
      }
    }
  }
  return paths;
}
import CountryLayout from '../../layouts/CountryLayout.astro';
import fs from 'fs';
import path from 'path';
const { lang, country } = Astro.params;
const countrySlug = Array.isArray(country) ? country.join('-') : country;
const contentPath = `../../../content/${lang}/${countrySlug}.json`;
let content = {};
try {
  content = await import(contentPath).then(m => m.default || m);
} catch (e) {
  return Astro.redirect('/404');
}
let translations = {};
try {
  translations = await import(`../../../locales/${lang}.json`).then(m => m.default || m);
} catch (e) {
  translations = {};
}
const translationsEn = await import(`../../../locales/en.json`).then(m => m.default || m);
// Fallback: si falta una clave en el idioma, usa la de inglés
const mergedTranslations = new Proxy(translations, {
  get(target, prop) {
    return prop in target ? target[prop] : translationsEn[prop];
  }
});
const availableLangs = fs.readdirSync(path.resolve('content')).filter(f => fs.existsSync(path.resolve('content', f, `${countrySlug}.json`)));
// Generar hreflangs para todos los idiomas disponibles de ese país
const hreflangs = {};
availableLangs.forEach(l => {
  const data = JSON.parse(fs.readFileSync(path.resolve('content', l, `${countrySlug}.json`), 'utf-8'));
  hreflangs[l] = data.slug;
});
---
<CountryLayout content={content} translations={mergedTranslations} availableLangs={availableLangs} currentLang={lang} countrySlug={countrySlug} hreflangs={hreflangs} />
